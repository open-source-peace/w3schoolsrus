<?php include '../include/head.php'; ?>
<title>Учебник по кибербезопасности. Сетевые атаки. <?php include '../include/title.php'; ?></title>
<meta name='description' content='Сетевые атаки. Переполнение буфера. Сканеры уязвимостей. Выполнение кода. Сетевой мониторинг. Одноранговый трафик. Боковое движение и поворот. Учебник по кибербезопасности. <?php include '../include/description.php'; ?>'>

<?php include '../include/topmenu.php'; ?>
<?php include '../include/leftmenu_cybersecurity.php'; ?>
<?php include '../include/before_content_cybersecurity.php'; ?>

<article>
    <h1>Кибербезопасность. <span class="color_h1">Сетевые атаки</span></h1>
    <div class="w3-clear nextprev">
        <a class="w3-left w3-btn" href="cybersecurity_mapping_port_scanning.php">&#10094; Prev</a>
        <a class="w3-right w3-btn" href="cybersecurity_web_applications_attacks.php">Next &#10095;</a>
    </div>
    <hr>
    <h2>Сетевые атаки</h2>
    <p>Атаки на протоколы и приложения, размещенные в Сети, многочисленны. Веб-приложения рассматриваются в отдельном разделе этого курса.</p>
    <p>Сервисы могут иметь изначальные ошибки, позволяющие злоумышленникам использовать их. Эти атаки обычно включают использование специальных инструкций для операционной системы через уязвимую службу, чтобы взять под контроль процесс, управляющий сетевой службой. Переполнение буфера - это категория таких атак.</p>
    <p>Сеть обычно содержит множество приложений, некоторые из которых содержат простые учётные записи, а другие - со сложной функциональностью. Один из способов получить общее представление о поверхности атаки, а также наметить уязвимости, которые легко использовать, - это сканирование портов всех активов в целевой среде, а затем их снимки экрана.</p>
    <p>Такие инструменты, как EyeWitness (Глаз-свидетель) (https://github.com/FortyNorthSecurity/EyeWitness), позволяют это сделать. Инструмент позволяет нам быстро получить представление о том, какие активы представлены в сети, а затем предоставляет снимки экрана (скриншоты) для каждой службы. Имея снимки экрана, мы можем легко посмотреть и быстро оценить, какие системы нам следует рассмотреть поближе.</p>
    <p>Использование сервиса означает злоупотребление сервисом не по назначению. Часто эта эксплуатационная деятельность означает, что злоумышленники могут запускать свой собственный код, это называется RCE (&quot;Remote Code Execution&quot; - &quot;Удаленное выполнение кода&quot;).</p>
    <hr>

    <h2>Переполнение буфера</h2>
    <p>Эксплуатация сетевых служб иногда включает злоупотребление функциями управления памятью приложения. Управление памятью? Да, приложениям необходимо перемещать данные в памяти компьютера, чтобы приложение работало. Когда языки программирования предоставляют разработчику контроль над памятью, могут возникнуть проблемы, подобные переполнению буфера. Существует много подобных уязвимостей, и в этом разделе мы рассмотрим переполнение буфера.</p>
    <p>Язык программирования C и C++ позволяет разработчикам полностью контролировать управление памятью. Это идеально подходит для приложений, которые требуют от разработчиков очень близкого программирования к оборудованию, но при этом открыты для уязвимостей. Такие языки программирования, как Java, JavaScript, C#, Ruby, Python и другие не позволяют разработчикам допускать подобные ошибки, что снижает вероятность переполнения буфера в приложениях, написанных на этих языках.</p>
    <p>Переполнение буфера происходит, когда необработанный ввод помещается в переменные. Эти переменные представлены в операционной системе через структуру памяти, называемую стеком. Затем злоумышленник может перезаписать часть стека, называемую указателем возврата.</p>

    <div class="w3-note w3-panel"><b>Примечание</b>. Структура памяти стека - это просто место, где программа хранит переменные и информацию, необходимую для запуска. Стек будет расположен в RAM (&quot;Random Access Memory&quot; - &quot;Оперативная память компьютера&quot;).</div>
    <p>Указатель возврата определяет, где CPU (&quot;Central Processing Unit&quot; - &quot;Центральный процессор компьютера&quot;) должен выполнять код следующим. ЦП просто контролирует, какие инструкции система должна выполнять в любой момент. Указатель возврата - это просто адрес в памяти, по которому должно произойти выполнение. ЦП всегда нужно указывать, где выполнять код, и это то, что ему позволяет делать указатель возврата.</p>
    <p>Когда злоумышленник может контролировать указатель возврата, это означает, что злоумышленник может контролировать, какие инструкции должен выполнять ЦП!</p>
    <p>Например, рассмотрим следующий пример кода C (не беспокойтесь, вам не обязательно быть разработчиком C, но постарайтесь понять, что делает это простое приложение):</p>
    <div class="w3-example">
        <div class="w3-code notranslate">#include &lt;string.h&gt;<br>
            void storeName (char *input) {<br>
            &nbsp;&nbsp;char name[12];<br>
            &nbsp;&nbsp;strcpy(name, input);<br>
            }<br>
            <br>
            int main (int argc, char **argv) {<br>
            &nbsp;&nbsp;storeName(argv[1]);<br>
            &nbsp;&nbsp;return 0;<br>
            }<br>
        </div></div>
    <p>Во многих языках программирования, включая C, приложение запускается в функции, называемой main. Это указано в приведенном выше коде, где указано <code>int main (int argc, char **argv) {</code>. В фигурных скобках {and} программа просто запускает функцию с именем <code>storeName (argv[1]);</code>. Она просто примет всё, что пользователь ввёл в программу, и предоставит это функции storeName.</p>
    <p>В приложении 11 строк кода, но обратите внимание на строку, которая читает <code>strcpy(name, input);</code>. Это функция, которая пытается скопировать текст из ввода в переменную с именем name. Имя может содержать не более 12 символов, как указано в строке <code>char name[12];</code>. Есть ли в коде место, которое препятствует тому, чтобы указанное имя было длиннее 12 символов? Переменная name предоставляется пользователем, который использует приложение, и передается непосредственно в функцию storeName.</p>
    <p>В этом приложении нет очистки или дезинфекции, чтобы убедиться, что длина входных данных соответствует ожиданиям приложения. Любой, кто запускает программу, может легко ввести значение, превышающее максимальное значение переменной name. Переменная name содержит 12 символов, но что произойдет, если ЦП прикажут записать более 12 символов? Он просто выполнит то, что было сказано, перезаписав столько памяти, сколько потребуется!</p>
    <p>При попытке записи значения, превышающего ожидаемое, ЦП все равно будет пытаться записать это значение в память. Это фактически заставляет ЦП перезаписывать другие данные в памяти, например, указатель возврата, позволяющий злоумышленникам управлять ЦП. Опять же, если злоумышленник может перезаписать указатель возврата и управлять им, он контролирует, какой код должен выполнять ЦП.</p>
    <p>Графический пример показывает, как Алиса записывает своё имя в приложение, которое мы использовали в примере выше:</p>
    <p><img src="../images/img_bufferoverflow.png" alt="Переполнение буфера" style="width:100%;max-width:1280px"></p>
    <p>Алиса ведёт себя хорошо и даёт имя, которое заставляет приложение вести себя должным образом. Она сообщает своё имя Алиса, и оно просто записывается в память приложения.</p>
    <p>Однако Ева отправляет в приложение слишком много символов. Что тогда происходит? ЦП эффективно принимает её входные данные и записывает их в память, а также перезаписывает другие существующие значения!</p>
    <p><img src="../images/img_bufferoverflow-exploited.png" alt="Использовать переполнение буфера" style="width:100%;max-width:1280px"></p>
    <p>Ввод Евы заставил ЦП записать гораздо больше данных, чем ожидало приложение, и это привело к перезаписи указателя возврата. Когда ЦП пытается выполнить следующую инструкцию, ему теперь предлагается выполнить код в местоположении <em>AAAAAAA</em>...</p>
    <p>Если бы Ева взяла на себя управление этим сервером, вместо того, чтобы писать A, ей пришлось бы вместо этого предоставить код, который ЦП может понять в памяти. Затем она заставит указатель возврата иметь значение, которое говорит ЦП выполнить собственный код ЦП Евы.</p>
    <div class="w3-panel w3-note"><b>Примечание</b>: Проще говоря, переполнение буфера позволяет злоумышленникам взять под контроль ЦП жертвы, тщательно перезаписав память жертвы.</div>
    <hr>

    <h2>Сканеры уязвимостей</h2>
    <p>Сканер уязвимостей автоматически ищет распространенные уязвимости в программном обеспечении и конфигурациях в сети. Он не предназначен для поиска новых классов уязвимостей, но вместо этого использует список предопределенных плагинов (или модулей) для сканирования служб на предмет проблем и уязвимостей. Необязательно искать уязвимости нулевого дня! Уязвимость нулевого дня - это совершенно новая уязвимость, о которой ранее не знали ни поставщик программного обеспечения, ни защитники; для уязвимости нулевого дня в настоящее время не существует известных исправлений проблемы.</p>
    <p>Сканеры имеют функции сетевого сопоставления и сканирования портов, включая способы исследования и поиска уязвимостей в различных приложениях, с которыми они сталкиваются.</p>
    <p>Сканер уязвимостей часто поддерживает конфигурацию с учётными данными, что позволяет ему входить в систему и оценивать уязвимости вместо того, чтобы находить их с неавторизованной точки зрения.</p>
    <div class="w3-panel w3-note"><b>Примечание:</b> Сканеры уязвимостей в основном ищут известные уязвимости и неправильные конфигурации, а не уязвимости нулевого дня!</div>
    <hr>

    <h2>Выполнение кода</h2>
    <p>Когда злоумышленники обнаруживают уязвимость, которую они могут использовать, им необходимо решить, какую полезную нагрузку они хотят запустить. Полезная нагрузка - это код, который злоумышленник хочет доставить с помощью эксплойта.</p>
    <p>Злоумышленник может решить использовать множество различных полезных данных. Вот несколько примеров:</p>
    <ul>
        <li>Заставить жертву зарегистрироваться на сервере C2 (&quot;"Command and Control&quot; - &quot;Командование и контроль&quot;), принимающем команды от злоумышленников.</li>
        <li>Создайте новую учетную запись пользователя бэкдора в системе, чтобы злоумышленник мог использовать её позже.</li>
        <li>Откройте GUI (&quot;Graphical User Interface&quot; - &quot;Графический Интерфейс Пользователя&quot;) с жертвой, чтобы злоумышленник мог удалённо управлять ею.</li>
        <li>Получите терминал командной строки, оболочку, через которую злоумышленник может отправлять команды.</li>
    </ul>
    <p> Обычно злоумышленники используют bind-shell. Это заставляет жертву прослушивать порт, и когда злоумышленник подключается, они получают оболочку.</p>
    <p><img src="../svg/img_bind-shell.svg" alt="Привязать оболочку" style="width:100%;max-width:1280px"></p>
    <p>Файерволы помогают предотвратить подключение злоумышленников к жертвам. Файервол будет эффективно отклонять входящие соединения с жертвой, пока порт не разрешен. Только одно приложение может прослушивать порт, поэтому злоумышленники не могут прослушивать порты, которые уже используются, если они не отключат эту службу.</p>
    <p>Чтобы обойти эту защитную меру, злоумышленники вместо этого попытаются заставить жертву подключиться к злоумышленнику, заставляя жертву предоставить доступ к полезной нагрузке. К сожалению, многие файерволы (брандмауэры) не настроены для запрета исходящего трафика, что делает эту атаку очень реальной для злоумышленников.</p>
    <p>В этом примере мы видим, как злоумышленник использует обратную оболочку, чтобы заставить жертву подключиться к злоумышленнику.</p>
    <p><img src="../svg/img_reverse-shell.svg" alt="Обратная оболочка" style="width:100%;max-width:1280px"></p>
    <div class="w3-panel w3-note"><b>Примечание:</b> Выполнение кода означает, что злоумышленники могут запустить свой код в системе жертвы. Какой код они выберут для развертывания, зависит от них, но это часто связано с тем, что злоумышленники имеют возможность запускать команды в системе жертвы в долгосрочной перспективе.</div>
    <hr>

    <h2>Сетевой мониторинг</h2>
    <p>Злоумышленникам в большинстве случаев требуется, чтобы сеть удаленно контролировала цель. Когда злоумышленники могут удаленно контролировать цель, это осуществляется через канал управления и контроля (Command and Control), часто называемый C&amp;C или C2.</p>
    <p>Существуют компромиссы с помощью вредоносного ПО, которое заранее запрограммировано с полезными нагрузками, которым не нужен C2. Вредоносные программы такого типа способны взломать даже сети с воздушным зазором.</p>
    <p>Обнаружение компрометации часто может быть выполнено путем обнаружения канала C2. C2 может принимать любую форму, например:</p>
    <ul>
        <li>Использование HTTPS для связи с серверами злоумышленников. Это делает C2 похожим на просмотр сети</li>
        <li>Использование социальных сетей для автоматической публикации и чтения сообщений</li>
        <li>Такие системы, как Google Docs, для добавления и редактирования команд жертвам</li>
    </ul>
    <p><img src="../images/img_networkmonitoring-beacon.png" alt="Маяк мониторинга сети" style="width:100%;max-width:1280px"></p>
    <p>Только изобретательность атакующего устанавливает предел для C2. При рассмотрении того, как остановить злоумышленников с помощью умных каналов C2, мы часто должны полагаться на обнаружение статистических аномалий и расхождений в сети. Например, инструменты сетевого мониторинга могут обнаруживать:</p>
    <ul>
        <li>Длинные соединения, используемые C2, что неестественно для рассматриваемого протокола. HTTP - один из тех протоколов, где длинные соединения не очень распространены, но злоумышленник, использующий его для удаленного управления, может его применять.</li>
        <li>Маяки, используемые C2, чтобы указать, что жертва жива и готова к командам. Маяки используются многими видами программного обеспечения, не только злоумышленниками, но знание того, какие маяки существуют и чего вы ожидаете, является хорошей практикой.</li>
        <li>Из сети внезапно появляются вспышки данных. Это может указывать на большую загрузку из приложения или на кражу данных злоумышленником. Попытайтесь понять, какое приложение и пользователь вызывает появление вспышек данных, и примените к ним контекст. Это нормально или нет?</li>
    </ul>
    <p>Есть много способов, которыми защитники могут попытаться найти аномалии. Эти аномалии следует дополнительно сопоставить с данными из исходной системы, отправляющей данные.</p>
    <p>Для мониторинга сети следует применять контекст, чтобы определить шум по сигналу. Это означает, что SOC (&quot;Security Operations Center - &quot;Центр управления безопасностью&quot;) должен попытаться дополнить данные, например IP-адреса источника и назначения, контекстом, чтобы сделать данные более ценными.</p>
    <p>Применение контекста можно описать следующим образом: атака приходит из Интернета, но пытается использовать уязвимость Linux в службе Windows. Обычно это рассматривается как шум, и его можно безопасно игнорировать; разве что, если IP-адрес, выполняющий атаку, является IP-адресом вашей собственной сети или провайдера, которому вы доверяете? Контекст, который мы можем применить, может дать ценную информацию о том, как мы исследуем атаку дальше. В конце концов, мы не хотим, чтобы системы, которым мы доверяли, запускали какие-либо атаки!</p>
    <hr>

    <h2>Peer to peer traffic - Одноранговый трафик</h2>
    <p>Большинство сетей настроены по принципу &quot;клиент-сервер&quot;. Клиент получает доступ к серверам для получения информации, и когда клиентам необходимо взаимодействовать друг с другом, они обычно делают это через сервер.</p>
    <p>Однако злоумышленник, скорее всего, захочет использовать одноранговую связь, то есть связь от клиента к клиенту, чтобы использовать низко висящие плоды, такие как повторное использование учетных данных или использование слабых или уязвимых клиентов.</p>
    <p>Например, порт 445, используемый SMB, является хорошим индикатором для обнаружения взлома. Клиенты не должны общаться друг с другом через SMB в большинстве сред, однако во время компрометации злоумышленник, скорее всего, попытается использовать SMB для дальнейшей компрометации систем.</p>
    <p><img src="../svg/img_peer-to-peer.svg" alt="Peer-to-Peer - Одноранговый трафик" style="width:100%;max-width:1280px"></p>
    <hr>

    <h2>Боковое движение и поворот</h2>
    <p>После взлома системы злоумышленник может использовать эту систему для исследования дополнительных сетей, к которым у взломанной системы есть доступ. Это было бы возможно в среде, где скомпрометированная система имеет больше привилегий через файервол или система имеет доступ к другим сетям, например, через дополнительную сетевую карту.</p>
    <p>Поворот означает, что злоумышленник использует взломанный хост для доступа в другие сети. Здесь показана иллюстрация этого, где Ева взломала одну систему и использует её для сканирования и обнаружения других:</p>
    <p><img src="../svg/img_pivoting-lateral-movement.svg" alt="Поворотное боковое движение" style="width:100%;max-width:1280px"></p>
    <p>Боковое движение - это действие, в котором используется поворотная точка и другая система с её помощью. Эту новую систему теперь можно использовать для поворотов и боковых движений. Ева в этом примере использует Сервер X для дальнейшего обнаружения Системы B.</p>
    <p><img src="../svg/img_pivoting-lateral-movement2.svg" alt="Поворотное боковое движение" style="width:100%;max-width:1280px"></p>
    <hr>
    <div class="w3-clear nextprev">
        <a class="w3-left w3-btn" href="cybersecurity_mapping_port_scanning.php">&#10094; Prev</a>
        <a class="w3-right w3-btn" href="cybersecurity_web_applications_attacks.php">Next &#10095;</a>
    </div>
</article>
<?php include '../include/addown_content.php'; ?>
</div>
<?php include '../include/rightbar.php'; ?>
<?php include '../include/footer.php'; ?>